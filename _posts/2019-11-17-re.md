---
layout: post
title: "正则表达式"
date: 2019-11-17 21:05:30 +0800
catalog: ture  
multilingual: false
tags: 
    - re
---

[toc]

### 常用

```bash
.          任意的一个字符
a|b        字符a或字符b
[afg]      a或者f或者g的一个字符
[0-4]      0-4范围内的一个字符
[a-f]      a-f范围内的一个字符
[^m]       不是m的一个字符
\s         一个空格
\S         一个非空格
\d         [0-9]
\D         [^0-9]
\w         [0-9a-zA-Z]
\W         [^0-9a-zA-Z]
*         重复 >=0 次
+         重复 >=1 次
?         重复 0或者1 次
{m}       重复m次。比如说 a{4}相当于aaaa，再比如说[1-3]{2}相当于[1-3][1-3]
{m, n}    重复m到n次。比如说a{2, 5}表示a重复2到5次。小于m次的重复，或者大于n次的重复都不符合条件。
```



### \b \B

```bash
#\b \B匹配单词的边界
r'\bthe'  匹配以the开头的字符串
\bthe\b   匹配the
\Bthe     包含the但是不以the开头
```



### \A \z \Z

```bash
# \A匹配输入字符串的开始位置   \Z匹配输入字符串的结束位置 
\A 和 \z 匹配的是整段输入，完完整整，不偏不倚，不管在单行模式还是多行模式下
\A 和 \Z 匹配的是整段输入，结尾终止子可有可无，不管在单行模式还是多行模式下
```



### ()   (?:)   (?=)   (?!)

```bash
一对圆括号和正则表达式一起使用时可以实现一下任意一个（或两个）功能：
1：对正则表达式进行分组
2：匹配子组
在子模式后面加上问号，它就变成了可选项。它可能出现在匹配字符串，但并非必须的。

# (?:)  
()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)
(?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来

#  (?=) (?!) 要理解?=和?!，首先需要理解前瞻，后顾，负前瞻，负后顾四个概念：

# 前瞻：
exp1(?=exp2) 查找exp2前面的exp1
# 后顾：
(?<=exp2)exp1 查找exp2后面的exp1
# 负前瞻：
exp1(?!exp2) 查找后面不是exp2的exp1
# 负后顾：
(?<!exp2)exp1 查找前面不是exp2的exp1

#例子
"中国人".replace(/(?<=中国)人/, "rr") # 匹配中国人中的人，将其替换为rr，结果为 中国rr
"法国人".replace(/(?<=中国)人/, "rr") # 结果为 法国人，因为人前面不是中国，所以无法匹配到
```



### IP匹配

```bash
A类：10.0.0.0--10.255.255.255
^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$
B类：172.16.0.0--172.31.255.255
^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$
C类：192.168.0.0--192.168.255.255
^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$
```



### 参考

[正则表达式边界符中的 ^, $, \A, \Z, \z](https://blog.csdn.net/justheretobe/article/details/53152267)

[正则表达式中?=和?:和?!的理解](https://blog.csdn.net/csm0912/article/details/81206848)